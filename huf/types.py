import typing as tp

import haiku as hk
import jax
import jax.numpy as jnp

Activation = tp.Callable[[jnp.ndarray], jnp.ndarray]
PRNGKey = jnp.ndarray  # presumably generated by jax.random.PRNGKey
Seed = int

Inputs = tp.Any
Labels = tp.Any
Preds = tp.Any
SampleWeight = tp.Any
Params = tp.Any
State = tp.Any

Metrics = tp.Mapping[str, tp.Any]


class Example(tp.NamedTuple):
    inputs: Inputs
    labels: tp.Optional[Labels]
    sample_weight: tp.Optional[SampleWeight]


class ModelState(tp.NamedTuple):
    params: tp.Any
    net_state: tp.Any
    opt_state: tp.Any


class FitState(tp.NamedTuple):
    epochs: int
    rng: PRNGKey
    model_state: ModelState


class FitResult(tp.NamedTuple):
    state: FitState
    train_metrics: Metrics
    validation_metrics: tp.Optional[Metrics]


MetricFactory = tp.Callable[[], hk.Module]

ArrayTree = tp.Union[
    jnp.ndarray, tp.Tuple["ArrayTree", ...], tp.Mapping[str, "ArrayTree"]
]

AbstractTree = tp.Union[
    jax.core.AbstractValue,
    tp.Tuple["AbstractTree", ...],
    tp.Mapping[str, "AbstractTree"],
]


class ModelSpec(tp.NamedTuple):
    inputs: AbstractTree
    labels: tp.Optional[AbstractTree]
    sample_weight: tp.Optional[AbstractTree]
    preds: AbstractTree
    metrics: AbstractTree
    params: AbstractTree
    net_state: AbstractTree
    opt_state: AbstractTree
    metrics_state: AbstractTree


class Objective(tp.NamedTuple):
    key: str  # into metrics, e.g. "loss"
    split: str  # see Splits
    mode: str  # see Modes


class Splits:
    TRAIN = "train"
    VALIDATION = "val"
    TEST = "test"

    @classmethod
    def all(cls):
        return (Splits.TRAIN, Splits.VALIDATION, Splits.TEST)

    @classmethod
    def validate(cls, split: str):
        if split not in cls.all():
            raise ValueError(f"invalid split '{split}' - must be one of {cls.all()}")


class Modes:
    MIN = "min"
    MAX = "max"

    @classmethod
    def all(cls):
        return (Modes.MIN, Modes.MAX)

    @classmethod
    def raise_invalid(cls, mode: str):
        raise ValueError(f"invalid mode '{mode}' - must be one of {cls.all()}")

    @classmethod
    def validate(cls, mode: str):
        if mode not in cls.all():
            cls.raise_invalid(mode)

    @classmethod
    def reducer(cls, mode: str):
        if mode == Modes.MIN:
            return min
        if mode == Modes.MAX:
            return max
        cls.raise_invalid(mode)

    @classmethod
    def comparator(cls, mode: str):
        if mode == Modes.MIN:
            return jnp.less
        if mode == Modes.MAX:
            return jnp.greater
        cls.raise_invalid(mode)

    @classmethod
    def default_value(cls, mode: str):
        if mode == Modes.MIN:
            return jnp.inf
        if mode == Modes.MAX:
            return -jnp.inf
        cls.raise_invalid(mode)
